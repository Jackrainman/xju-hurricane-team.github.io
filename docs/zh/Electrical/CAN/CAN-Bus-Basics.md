> **最近修改日期**：2026-01-27
>
> **参与者**：Jackrainman

# CAN 总线通信原理与软件驱动架构

## 1. 概述

CAN (Controller Area Network) 是一种广泛应用于汽车与工业控制的串行通信协议。在机器人开发中，CAN 总线因其走线简单（节省线束）和极高的抗干扰能力，成为电控系统（ECU）之间通信的首选方案。

通信系统由三个层级构成：

* **物理层（硬件）**：包括单片机、CAN 收发器与双绞线。
* **数据链路层（控制器）**：STM32 内部集成的 bxCAN 或 FDCAN 外设。
* **应用层（软件）**：基于 `can_list.c` 驱动的协议解析与业务处理。

## 2. 物理层：差分信号与抗干扰原理

CAN 收发器负责将单片机的逻辑信号转换为总线上的差分信号。

### 2.1 差分信号定义

CAN 总线使用两根信号线：**CAN_H** (High) 和 **CAN_L** (Low)。接收端通过比较两根线的电压差来判断逻辑状态。

* **显性电平 (Dominant, 逻辑 0)**
* CAN_H 拉高 (约 3.5V)，CAN_L 拉低 (约 1.5V)。
* 电压差约为 2V。
* **特性**：总线上只要有一个节点发送“显性”，总线即呈现“显性”状态（线与机制）。


* **隐性电平 (Recessive, 逻辑 1)**
* CAN_H 和 CAN_L 均维持在中间电压 (约 2.5V)。
* 电压差近乎 0V。
* **特性**：只有所有节点都处于“隐性”时，总线才呈现“隐性”状态。



### 2.2 抗干扰机制

CAN 总线通过双绞线传输差分信号，能有效抵御电机启动等高噪环境下的共模干扰。

**案例分析**：
假设主控制器 (Master) 向电机 (Device) 发送逻辑“0”。

1. **正常发送**：Master 输出 CAN_H=3.5V，CAN_L=1.5V，差值 。
2. **干扰引入**：外界产生 +1.0V 的共模干扰（如电压尖峰）。由于双绞线紧密缠绕，干扰同时作用于两线：
* CAN_H 变为 4.5V (3.5 + 1.0)。
* CAN_L 变为 2.5V (1.5 + 1.0)。


3. **差分解码**：接收端仅计算差值：。
4. **结论**：尽管绝对电压发生偏移，但差值保持不变，数据仍被正确识别为“0”。

## 3. 硬件抽象层：从电压到数据

软件驱动并不直接处理电压，而是基于 STM32 内部控制器（bxCAN 或 FDCAN）解码后的数据进行操作。

* **组包与校验**：当差分信号传输完成，硬件控制器自动将其组装为一帧报文（包含 ID、数据长度 DLC、数据 Data），并存入硬件 FIFO（First In First Out，先进先出队列）。
* **中断触发**：数据存入 FIFO 后，触发接收中断（如 `HAL_CAN_RxFifo0MsgPendingCallback`），通知 CPU 进行处理。

## 4. 软件驱动架构 (can_list)

本战队使用的 `can_list` 驱动采用分层设计，旨在解决高频中断下的实时性问题及多设备 ID 的快速检索。

### 4.1 第一阶段：中断接收 (ISR)

此阶段为信号入口，位于 `can_list.c` 的中断服务函数中。

* **中断源区分**：兼容 FDCAN (H7/G4系列) 和 bxCAN (F1/F4系列) 的中断接口。
* **处理模式**：
* **RTOS 模式 (推荐)**：为了保证系统实时性，ISR (Interrupt Service Routine) 不直接解析数据。它构建一个轻量级通知，通过 FreeRTOS 队列 (`xQueueSendFromISR`) 发送至后台任务，随即退出中断。
* **非 RTOS 模式**：在中断内直接调用处理函数，适用于简单应用，但可能阻塞其他高优先级任务。



### 4.2 第二阶段：数据分发 (核心逻辑)

此阶段由后台任务 (`can_list_polling_task`) 执行，负责将原始数据映射到具体设备。

* **读取寄存器**：通过 HAL 库函数 (`HAL_CAN_GetRxMessage`) 从硬件 FIFO 读取解码后的报文。
* **哈希查表 (Hash Lookup)**：
* 利用 `ID % table_length` 计算哈希桶索引，快速定位链表头。
* 此算法将遍历搜索的时间复杂度大幅降低，适合挂载大量电机的场景。


* **掩码匹配 (Masking)**：
* 遍历链表时，不仅对比 ID，还引入了 **掩码 (Mask)** 机制。
* **应用场景**：若掩码设为 `0xFF`，则 ID `0x12340201` 和 `0xAAAA0201` 均匹配注册 ID `0x01`。这允许驱动统一处理某一类设备的反馈（如提取低 8 位作为子 ID）。



### 4.3 第三阶段：业务回调 (Callback)

一旦匹配成功，驱动将执行最终的业务逻辑。

* **数据标准化**：将不同硬件（bxCAN/FDCAN）的数据格式统一封装为 `can_rx_header_t` 结构体。
* **执行回调**：
* 调用用户注册的函数指针：`node->callback(node->can_data, ...)`。
* **面向对象设计**：`can_data` 指针通常指向具体的电机对象。用户在回调中直接操作该指针，无需通过全局变量查找电机，实现了代码的高内聚低耦合。

