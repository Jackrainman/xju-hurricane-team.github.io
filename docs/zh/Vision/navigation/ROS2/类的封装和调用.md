  ## 类的封装与调用

  ​	如果你想用一个代码调用一个功能，那么当你面对需要同时调用多个功能的问题时就需要繁复地写各种.cpp文件，例如，你不仅需要/Odometry的数据，还要/Pointcloud的数据，还要其他各种各样的数据。面对这样的问题，有个简单的办法就是把各种调用的部分进行封装，但是封装也不是一件容易的事，下面仍以livox-mid360为例，说明如何封装自己写的类，并且学会写CMakeLists，不仅可以帮助你学会如何编写一个功能包，更能让你面对报错时知道该从哪里找问题所在。

  

  #### 1）功能包结构图

  ​	此处工作空间命名为livox_odom_ws，功能包自定义为livox_odom，后续不再说明，想要封装一个类，需要的结构图如图所示。

  ```
livox_odom_ws/
├── src/
│   ├── livox_odom/
│   │   ├── include/livox_odom/odom_processor.hpp  # 头文件
│   │   ├── src/odom_processor.cpp                 # 实现文件
│   │   ├──    /main.cpp                           # 主程序
│   │   └── CMakeLists.txt
│   └── ...
└── ...
  ```

  ​	可以看到，总共需要新添加三个文件，分别是在include/livox_odom下的odom_processor.hpp，在src下的两个文件，分别是odom_processor.cpp，和主程序main.cpp。当然，最重要的还有CMakeLists的编写。

  ​	对于多个话题的数据处理的大概架构流程如下所示：

  ```
	A[雷达1话题] --> B[数据解析]
    C[雷达2话题] --> D[数据解析]
    B --> E[数据融合]
    D --> E
    E --> F[目标检测]
    F --> G[结果发布]
  ```

  

  #### 2）头文件的编写

  ​	下面是odom_processor.hpp的代码，并附以较为详细的解释。

  ```
#pragma once
#include "rclcpp/rclcpp.hpp"
#include "nav_msgs/msg/odometry.hpp"
#include "tf2/LinearMath/Quaternion.h"
#include "tf2/LinearMath/Matrix3x3.h"

namespace livox_odom {

class OdomProcessor : public rclcpp::Node {
public:
    // 构造函数显式指定话题名称
    OdomProcessor(const std::string& node_name = "odom_processor_node");
    
    // 数据存储结构体
    struct OdomData {
        double x = 0.0, y = 0.0, z = 0.0;           // 位置坐标（米）
        double roll = 0.0, pitch = 0.0, yaw = 0.0;  // 欧拉角（弧度）
    };
    
    // 获取最新数据的线程安全方法
    OdomData get_current_data() const;

private:
    void odom_callback(const nav_msgs::msg::Odometry::SharedPtr msg);
    OdomData current_data_;
    rclcpp::Subscription<nav_msgs::msg::Odometry>::SharedPtr odom_sub_;
};类的封装与调用
  ​	如果你想用一个代码调用一个功能，那么当你面对需要同时调用多个功能的问题时就需要繁复地写各种.cpp文件，例如，你不仅需要/Odometry的数据，还要/Pointcloud的数据，还要其他各种各样的数据。面对这样的问题，有个简单的办法就是把各种调用的部分进行封装，但是封装也不是一件容易的事，下面仍以livox-mid360为例，说明如何封装自己写的类，并且学会写CMakeLists，不仅可以帮助你学会如何编写一个功能包，更能让你面对报错时知道该从哪里找问题所在。

  

1）功能包结构图
  ​	此处工作空间命名为livox_odom_ws，功能包自定义为livox_odom，后续不再说明，想要封装一个类，需要的结构图如图所示。

￼
livox_odom_ws/
├── src/
│   ├── livox_odom/
│   │   ├── include/livox_odom/odom_processor.hpp  # 头文件
│   │   ├── src/odom_processor.cpp                 # 实现文件
│   │   ├──    /main.cpp                           # 主程序
│   │   └── CMakeLists.txt
│   └── ...
└── ...
  ​	可以看到，总共需要新添加三个文件，分别是在include/livox_odom下的odom_processor.hpp，在src下的两个文件，分别是odom_processor.cpp，和主程序main.cpp。当然，最重要的还有CMakeLists的编写。

  ​	对于多个话题的数据处理的大概架构流程如下所示：

￼
    A[雷达1话题] --> B[数据解析]
    C[雷达2话题] --> D[数据解析]
    B --> E[数据融合]
    D --> E
    E --> F[目标检测]
    F --> G[结果发布]
  

2）头文件的编写
  ​	下面是odom_processor.hpp的代码，并附以较为详

} // namespace livox_odom
  ```

  ​	其中#pragma once 用于避免重复引用头文件导致报错，这一部分读者可自行了解。具体说明：[C++中#param once使用以解决multiple definition错误-CSDN博客](https://blog.csdn.net/weixin_45533366/article/details/144242913#:~:text=%23param once作用是避免重复引用头文件导致多重定义的问题，例如如下结构： ├──src%2F ├── main.cpp ├── file1.cpp └──,├── b.h └── c.h 如果我们在 a.h 中定义了 全局变量)

  ​	livox_odom是命名空间，命名空间内可以存放变量和函数，或是类，同时，命名空间中的函数也可以在命名空间外定义。如果调用命名空间中的函数，要记得添加上作用域，也可以在外部的时候单独创建一个函数，在函数内部调用命名空间中的变量或类时也要添加上作用域。具体说明：[详解c++的命名空间namespace - 知乎](https://zhuanlan.zhihu.com/p/126481010)

  ​	在public构造函数中的各种参数的含义如下表：

| 部分           | 含义                                     | ROS2 开发中的意义                             |
| :------------- | :--------------------------------------- | :-------------------------------------------- |
| `const`        | 表示参数是只读的，函数内部不能修改它的值 | 确保节点名称不会被意外修改                    |
| `std::string&` | 字符串的引用（避免拷贝开销）             | 高效传递节点名称（ROS2 节点名称通常是字符串） |
| `node_name`    | 参数名称，开发者自定义的标识符           | 用于接收外部传入的节点名称                    |

类的封装与调用
  	如果你想用一个代码调用一个功能，那么当你面对需要同时调用多个功能的问题时就需要繁复地写各种.cpp文件，例如，你不仅需要/Odometry的数据，还要/Pointcloud的数据，还要其他各种各样的数据。面对这样的问题，有个简单的办法就是把各种调用的部分进行封装，但是封装也不是一件容易的事，下面仍以livox-mid360为例，说明如何封装自己写的类，并且学会写CMakeLists，不仅可以帮助你学会如何编写一个功能包，更能让你面对报错时知道该从哪里找问题所在。

  

1）功能包结构图
  	此处工作空间命名为livox_odom_ws，功能包自定义为livox_odom，后续不再说明，想要封装一个类，需要的结构图如图所示。

￼
livox_odom_ws/
├── src/
│   ├── livox_odom/
│   │   ├── include/livox_odom/odom_processor.hpp  # 头文件
│   │   ├── src/odom_processor.cpp                 # 实现文件
│   │   ├──    /main.cpp                           # 主程序
│   │   └── CMakeLists.txt
│   └── ...
└── ...
  	可以看到，总共需要新添加三个文件，分别是在include/livox_odom下的odom_processor.hpp，在src下的两个文件，分别是odom_processor.cpp，和主程序main.cpp。当然，最重要的还有CMakeLists的编写。

  	对于多个话题的数据处理的大概架构流程如下所示：

￼
    A[雷达1话题] --> B[数据解析]
    C[雷达2话题] --> D[数据解析]
    B --> E[数据融合]
    D --> E
    E --> F[目标检测]
    F --> G[结果发布]


2）头文件的编写
  	下面是odom_processor.hpp的代码，并附以较为详细的解释。

￼
#pragma once
#include "rclcpp/rclcpp.hpp"
#include "nav_msgs/msg/odometry.hpp"
#include "tf2/LinearMath/Quaternion.h"
#include "tf2/LinearMath/Matrix3x3.h"

namespace livox_odom {

class OdomProcessor : public rclcpp::Node {
public:
    // 构造函数显式指定话题名称
    OdomProcessor(const std::string& node_name = "odom_processor_node");
    

    // 数据存储结构体
    struct OdomData {
        double x = 0.0, y = 0.0, z = 0.0;           // 位置坐标（米）
        double roll = 0.0, pitch = 0.0, yaw = 0.0;  // 欧拉角（弧度）
    };
    
    // 获取最新数据的线程安全方法
    OdomData get_current_data() const;

private:
    void odom_callback(const nav_msgs::msg::Odometry::SharedPtr msg);
    OdomData current_data_;
    rclcpp::Subscription<nav_msgs::msg::Odometry>::SharedPtr odom_sub_;
};类的封装与调用
  • 如果你想用一个代码调用一个功能，那么当你面对需要同时调用多个功能的问题时就需要繁复地写各种.cpp文件，例如，你不仅需要/Odometry的数据，还要/Pointcloud的数据，还要其他各种各样的数据。面对这样的问题，有个简单的办法就是把各种调用的部分进行封装，但是封装也不是一件容易的事，下面仍以livox-mid360为例，说明如何封装自己写的类，并且学会写CMakeLists，不仅可以帮助你学会如何编写一个功能包，更能让你面对报错时知道该从哪里找问题所在。

  

1）功能包结构图
  • 此处工作空间命名为livox_odom_ws，功能包自定义为livox_odom，后续不再说明，想要封装一个类，需要的结构图如图所示。

￼
livox_odom_ws/
├── src/
│   ├── livox_odom/
│   │   ├── include/livox_odom/odom_processor.hpp  # 头文件
│   │   ├── src/odom_processor.cpp                 # 实现文件
│   │   ├──    /main.cpp                           # 主程序
│   │   └── CMakeLists.txt
│   └── ...
└── ...
  • 可以看到，总共需要新添加三个文件，分别是在include/livox_odom下的odom_processor.hpp，在src下的两个文件，分别是odom_processor.cpp，和主程序main.cpp。当然，最重要的还有CMakeLists的编写。

  • 对于多个话题的数据处理的大概架构流程如下所示：

￼
    A[雷达1话题] --> B[数据解析]
    C[雷达2话题] --> D[数据解析]
    B --> E[数据融合]
    D --> E
    E --> F[目标检测]
    F --> G[结果发布]


2）头文件的编写
  • 下面是odom_processor.hpp的代码，并附以较为详

} // namespace livox_odom
  	其中#pragma once 用于避免重复引用  ​	显然，此处的node_name即节点名称为odom_processor_node，在使用这个类的时候可以不用再写入节点名称，将会默认为odom_processor_node。

  ​	继续说明：`OdomData get_current_data() const;` ，OdomData是自己创建的结构体，用于封装从/Odometry中读取到的数据，get_current_data()则是读取到原始数据之后的数据副本，这个代码和 int a 没有什么区别，OdomData就是一种类型(你自己定义的)，get_current_data() 则是变量，用于后续的调用和操作。 const则是声明该函数为常量成员函数，函数内部不会修改类的任何成员变量。

  ​	在private中的 odom_callback 与上文中的回调函数没有区别，不做说明。OdomData current_data_同上。

  ```
rclcpp::Subscription<nav_msgs::msg::Odometry>::SharedPtr odom_sub_;
  ```

  ​	这条语句表示ROS2的订阅，其中 <> 内的 nav_msgs::msg::Odometry 表示订阅的消息类型，odom_sub_是订阅者的对象的变量名，后续订阅话题内容需要通过这个变量。

  

  #### 3）实现文件的编写

  ​	实现文件即odom_processor.cpp，下面是具体的代码

  ```
#include "livox_odom/odom_processor.hpp" 

namespace livox_odom {
	// OdomProcessor是在public中定义的,外部引用需要添加作用域
    OdomProcessor::OdomProcessor(const std::string& node_name) 
    : Node(node_name) {
        odom_sub_ = create_subscription<nav_msgs::msg::Odometry>(
            "/Odometry", 
            10,
            [this](const nav_msgs::msg::Odometry::SharedPtr msg) {
                odom_callback(msg);
            });
    }

    void OdomProcessor::odom_callback(const nav_msgs::msg::Odometry::SharedPtr msg) {
        // 存储位置数据
        current_data_.x = msg->pose.pose.position.x;
        current_data_.y = msg->pose.pose.position.y;
        current_data_.z = msg->pose.pose.position.z;
        
        // 四元数转欧拉角
        tf2::Quaternion q(
            msg->pose.pose.orientation.x,
            msg->pose.pose.orientation.y,
            msg->pose.pose.orientation.z,
            msg->pose.pose.orientation.w);
        
        tf2::Matrix3x3 m(q);
        m.getRPY(current_data_.roll, current_data_.pitch, current_data_.yaw);
    }

    OdomProcessor::OdomData OdomProcessor::get_current_data() const {
        return current_data_;
    }

} // namespace livox_odom
  ```

  ​	头文件直接调用之前编写的"livox_odom/odom_processor.hpp"，需要注意此处的livox_odom是因为功能包的名字是livox_odom，即hpp文件在这个功能包下。命名空间不做赘述。

  ​	构造函数的使用和**C++编写ROS2节点**类似，只不过写法上略有不同，而写法上的区别则是因为此处是通过.hpp文件调用的，不用再重新声明 public rclcpp::Node 。用头文件中的订阅者的对象的变量名做话题订阅。话题的订阅部分与上文大致相似，有所区别的则是对回调函数的处理部分。

  ​	这个回调函数是一个C++ lambda表达式，用于定义ROS2订阅者的回调函数，（关于lambda函数的各种捕获和语法可以自行查阅）各部分含义如下：

| 代码部分     | 说明                             |
| :----------- | :------------------------------- |
| `[this]`     | 捕获列表：指定外部变量的捕获方式 |
| `(参数列表)` | 函数参数：与普通函数参数定义相同 |
| `{ 函数体 }` | 执行逻辑：收到消息时执行的操作   |

  ​	回调函数odom_callback的具体内容与其余部分类似，此处不做赘述。此处单独说明 get_current_data() 函数，该函数的意义是作为一个数据读取接口，用于从类中安全地读取当前存储的里程计数据，为外部代码提供current_data_。下面是代码的解析部分。

| 代码部分                          | 说明                                   |
| :-------------------------------- | :------------------------------------- |
| `OdomProcessor::OdomData`         | 返回类型（自定义结构体）               |
| `OdomProcessor::get_current_data` | 类成员函数限定符                       |
| `() const`                        | 声明为常量成员函数（不可修改成员变量） |

  > ​	在这个.cpp文件的末尾，可以通过RCLCPP_COMPONENTS_REGISTER_NODE函数将其转变为一个节点，用于后续的调用。

  

  #### 4）主程序的编写

  ​	main.cpp即主程序，一般也是在这里进行数据的读取和操作，具体代码如下：

  ```
#include "livox_odom/odom_processor.hpp"  
#include <chrono>  // 时间库(用于sleep_for)
#include <thread>  // 多线程支持
#include <iomanip> // 输出格式化

// 弧度转角度转换函数
constexpr double rad2deg(double radians) {
    return radians * 180.0 / M_PI;
}

int main(int argc, char** argv) {
    rclcpp::init(argc, argv);
    
    // 创建里程计处理实例
    auto odom_processor = std::make_shared<livox_odom::OdomProcessor>();
    
    // 启动ROS2运行线程
    std::thread ros_thread([&]() {
        rclcpp::spin(odom_processor);
    });
    
    // 控制台输出线程
    while (rclcpp::ok()) {
    	// 获取里程计数据 
        auto data = odom_processor->get_current_data();
    
        // 位置输出（保留3位小数）
        std::cout << std::fixed << std::setprecision(3);
        std::cout << "位置 (m):\n  X: " << data.x 
                    << "\n  Y: " << data.y 
                    << "\n  Z: " << data.z << std::endl;
        /*
        std::cout << "\n\n姿态 (deg):\n  Roll: " << rad2deg(data.roll)
                    << "\n  Pitch: " << rad2deg(data.pitch)
                    << "\n  Yaw: " << rad2deg(data.yaw) << std::endl;
        */
        
        // 2Hz输出频率
        std::this_thread::sleep_for(std::chrono::milliseconds(250));
    }
    
    ros_thread.join();
    rclcpp::shutdown();
    return 0;
}
  ```

  ​	首先是弧度转角度函数中，函数名有一个constexpr，这是编译期的计算优化。下面说明一下关于启动ROS2线程部分的代码。

| 代码段                         | 说明                                 |
| :----------------------------- | :----------------------------------- |
| `std::thread ros_thread`       | 创建一个名为 `ros_thread` 的线程对象 |
| `[&]()`                        | Lambda表达式捕获列表和参数列表       |
| `rclcpp::spin(odom_processor)` | ROS2核心事件处理函数                 |

  ​	如果想要创建多个线程同步进行(需要同时读取多个话题数据)，则可以采用如下方法：

  ```
// 创建多个节点线程
std::thread node1_thread([&](){ rclcpp::spin(node1); });
std::thread node2_thread([&](){ rclcpp::spin(node2); });
  ```

  ​	多线程的架构流程大概如下：

  ```
	A[主线程 main] --> B[创建 ros_thread]
    B --> C[执行 rclcpp::spin]
    A --> D[执行数据输出循环]
    C --> E[处理ROS2消息]
    D --> F[控制台打印]
  ```

  

  #### 5） CMakeLists的编写

  ​	CMakeLists是极其重要的一个部分，能否成功编译，是否能成功执行都需要关注CMakeLists中的内容。在生成功能包时就已经会生成大部分内容，因此这里仅展示需要额外添加的部分。下面是具体的写法展示与大致说明：

  ```
# 添加头文件搜索路径,让编译器能够找到自定义文件,第二行表示显式指定绝对路径
# 即确保在编译时能找到odom_processor.cpp和main.cpp时能找到#include "livox_odom/odom_processor.hpp"头文件
target_include_directories(odom_processor PUBLIC
  "$<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/include>"
  "$<INSTALL_INTERFACE:include>"
)


# 将src/odom_processor.cpp编译成静态库libodom_processor.a
add_library(odom_processor
  src/odom_processor.cpp
)


# 使用 ament_target_dependencies 管理依赖
ament_target_dependencies(odom_processor
  PUBLIC
  rclcpp
  nav_msgs
  geometry_msgs
  tf2
  tf2_ros
  std_msgs
)


# 可执行文件配置
# 将src/main.cpp编译为可执行文件odom_node,则在ros2 run时,启动的可执行文件也是odom_node
add_executable(odom_node
  src/main.cpp
)


# 链接依赖（显式传递所有必要目标）
target_link_libraries(odom_node
  odom_processor
  ${nav_msgs_LIBRARIES}                                     # nav_msgs必须使用这种链接方式，否则会报错
  rclcpp::rclcpp
  tf2::tf2
  tf2_ros::tf2_ros
)


# 安装配置
install(TARGETS    											# 将生成的库和可执行文件安装到install/lib/livox_odom
  odom_processor   											# 生成的库
  odom_node       					 						# 生成可执行文件(缺失会报错No add_executable found)
  DESTINATION lib/${PROJECT_NAME}  							# 目的地是功能包名
)


# 关键：导出依赖项
ament_export_dependencies(
  rclcpp
  nav_msgs
  geometry_msgs
  tf2
  tf2_ros
  std_msgs
)

ament_export_include_directories(
  include
)

ament_export_libraries(
  odom_processor
)

ament_package()
  ```

  ​	你生成的可执行文件的名称是依赖于CMakeLists中的，如果此处 add_executable 中生成的可执行文件名是main，那么在可执行文件链接的部分也要修改odom_node成main，安装配置中也要修改，避免安装错可执行文件。在运行时，运行的命令语句为：

  ​	`ros2 run <package_name> <executable_name>`

  ​	<executable_name>就是你的可执行文件名。

  ​	CMakeLists的完整工作流程如下所示：

  ```
	A[CMakeLists.txt] --> B[配置编译规则]  // 此处一般生成功能包时已经存在
    B --> C[编译odom_processor.cpp为库]
    B --> D[编译main.cpp为可执行文件]
    C --> E[链接ROS2依赖库]
    D --> E[链接自己编写的依赖库]
    E --> F[安装到install目录]
    F --> G[通过ros2 run调用]
  ```

